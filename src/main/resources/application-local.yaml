spring:
  application:
    name: API Guard
  data:
    redis:
      port: 6379
      host: localhost

detectors:
  bruteforce:
    enabled: true
    threshold:
      username: 5
      ip: 6
      user-ip: 3
    expiry-minutes: 12      # TTL for bucket keys
    cool-off-seconds: 60    # lock TTL when tripped
    windowSeconds: 60       # sliding window size for raw request rate
    maxEventsPerScope: 2000 # max events per scope (username, IP, user-IP) in the window
  enumeration:
    enabled: true
    threshold: 3                  # Unique usernames from a single principal in 'windowMinutes' to trigger
    bucketMinutes: 1              # Bucket granularity (minutes); usually 1 for minute-level resolution
    # IMPORTANT: Keep >= windowMinutes + bucketMinutes to avoid losing data early

    # === Lock settings ===
    coolOffSeconds: 120           # How long to block a principal after detection (seconds)
    includeUserAgentInPrincipal: true  # Use IP+UserAgent as principal ID to reduce NAT false positives

    # === Signal B: distinct IPs per username ===
    userIpsThreshold: 30          # Distinct IPs hitting the same username to trigger

    # === Signal C: per-principal raw request rate ===
    ipRateLimit: 90                # Max requests allowed per principal in ipRateWindowSeconds
    ipRateWindowSeconds: 60        # Sliding window size for raw request limiter (seconds)
  replay:
    enabled: true
    protected-methods: [POST, PUT, PATCH, DELETE]
    window-millis: 120000
    abuse-threshold: 3
    cool-off-seconds: 120
    include-user-agent-in-principal: true
    max-body-bytes: 65536
    canonicalize-json: true
    idempotency-header-names: [Correlation-Id, Idempotency-Key, X-Request-Id]
    ignored-query-params: [utm_source, utm_medium, utm_campaign, utm_term, utm_content, tracking_id]
  ip-rate-limit-abuse:
    # Master switch for this detector (true = enforce, false = completely off)
    enabled: true

    # Principal identity: if true -> ipua:<ip>:<uaHash>, else -> ip:<ip>
    # Turn ON to reduce false positives behind large NATs/proxies (more keys in Redis).
    includeUserAgentInPrincipal: true

    # Principals or raw IPs that bypass the detector entirely.
    # Examples: ["ip:127.0.0.1", "10.0.0.5", "ipua:203.0.113.7:12345678"]
    allowlist: []

    # Ant-style path patterns to exclude from rate limiting (health checks, metrics, static files, etc.)
    # Examples:
    # - "/actuator/**"
    # - "/health"
    # - "/static/**"
    excludePatterns: []

    # On Redis/script error: true = allow traffic (fail-open), false = block (fail-closed)
    # Prefer true for public endpoints; consider false for highly sensitive mutations.
    failOpenOnRedisError: true

    # Adds random +0..(N%) to lock TTL to avoid synchronized unlock spikes (e.g., 0.10 = up to +10%)
    lockJitterPercent: 0.10

    # ===== Strike escalation (principal scope only) =====
    # If true, repeat offenders get longer locks based on strike count in the strike window.
    strikeEscalationEnabled: true

    # How long a strike "sticks" for escalation (seconds). Larger = harsher over time.
    strikeWindowSeconds: 600

    # Lock durations for 1st, 2nd, and 3rd+ strike (seconds). These are *minimums*; jitter may add a bit more.
    strike1LockSeconds: 60
    strike2LockSeconds: 300
    strike3LockSeconds: 1800

    # Base cool-off (seconds) used when any scope trips (subnet/UA use this; principal may escalate above it).
    coolOffSeconds: 60

    # ===== Extra scopes =====
    # Subnet limiting (helps blunt botnets rotating across nearby IPs).
    subnetRateLimitEnabled: true

    # User-Agent limiting (helps flag abusive SDKs or UA-rotation patterns).
    userAgentRateLimitEnabled: true

    # Subnet grouping precision (defaults: IPv4 /24, IPv6 /64). Larger prefix = broader grouping.
    subnetIpv4Prefix: 24
    subnetIpv6Prefix: 64

    # ===== Per-scope token-bucket limits =====
    # Each scope has its own "bucket" with a burst (max-credits), refill rate (credits-per-second),
    # and per-request cost (credits-per-request). Effective sustained RPS ≈ cps / cost. Burst ≈ max / cost.

    # Principal scope (ip: or ipua:)
    ip:
      # Max burst capacity (bigger = larger short spikes allowed)
      max-credits: 10
      # Refill rate per second (bigger = higher sustained throughput allowed)
      credits-per-second: 2
      # Cost per request (bigger = each request drains more; effective RPS ↓)
      credits-per-request: 1
      # Optional: idle TTL for the Redis state key (cleanup only; detector computes safe default if omitted)
      # idle-ttl: 30m

    # Subnet scope (usually stricter to blunt spray attacks)
    subnet:
      max-credits: 5        # lower burst across the subnet
      credits-per-second: 0.5  # lower sustained rate across the subnet
      # credits-per-request: 1   # (defaults to 1 if omitted)
      # idle-ttl: 30m

    # User-Agent scope (moderate)
    user-agent:
      max-credits: 8
      credits-per-second: 1
      # credits-per-request: 1   # (defaults to 1 if omitted)
      # idle-ttl: 30m
  device-anomaly:
    enabled: true
    # List of HTTP headers used to uniquely identify a device
    identifierHeaderCandidates: ["x-vendor-id", "x-fingerprint-id"]

    # Whether to include the User-Agent string as part of device identity
    includeUserAgentInPrincipal: false

    # Whether to fall back to IP address as device identity if headers are missing
    fallbackToIp: false

    # Time window in seconds (10 min) for counting anomalies
    windowSeconds: 600

    # Max number of distinct IPs a single device can use in the window before triggering suspicion
    distinctIpThreshold: 2

    # Number of times IP can switch in the window before being flagged
    ipSwitchThreshold: 6

    # Duration in seconds to keep a flagged device in a restricted "cool-off" state
    coolOffSeconds: 120

    # Actions to take when a device is fanning out across multiple IPs
    actionsOnFanout: ["CHALLENGE_MFA", "RATE_LIMIT"]

    # Actions to take when device identifiers are rapidly changing
    actionsOnChurn: ["CHALLENGE_CAPTCHA"]

    # Actions to take while a device is in the locked/cool-off state
    actionsDuringLock: ["RATE_LIMIT"]

    # URL path patterns to ignore in anomaly detection
    excludePatterns: ["/health", "/metrics"]

    maxIpsPerDevice: 2
  traffic-anomaly:
    enabled: true
    # Learns baseline steadily, adapts within minutes but not jittery
    alpha: 0.22
    # Require a strong deviation from normal for an alert (≈ 4σ)
    z-threshold: 4.0
    # Guard against single-source noise; expect distributed surges
    min-distinct-ips: 3
    # Don’t alert until we’ve seen enough distinct minutes
    min-sample-minutes: 15
    # Union of the last N minute-buckets when counting distinct IPs
    window-minutes: 5
    bucket-minutes: 1
    # Keep buckets slightly longer than the window (cleanup via TTL)
    expiry-minutes: 15
    # How long to keep an endpoint in a soft cool-off once tripped
    cool-off-seconds: 180
    exclude-patterns: ["/health", "/metrics", "/static", "/favicon"]
  ddos:
    enabled: false                    # If false, detect() returns Optional.empty()
    keyPrefix: "ag"                  # Redis key namespace prefix (e.g., ag:ip:1.2.3.4:s1)
    # Fixed-window TTLs (seconds)
    windowsS1TtlSeconds: 2           # TTL for 1s bucket keys
    windowsS10TtlSeconds: 20         # TTL for 10s bucket keys
    windowsUniqTtlSeconds: 180       # TTL for distinct-IP HyperLogLog keys
    # Thresholds — tune from production histograms
    thresholdsPerIpS1: 30            # Max requests per IP per 1s bucket
    thresholdsPerIpS10: 150          # Max requests per IP per 10s bucket
    thresholdsGlobalS1: 2000         # Max total requests across all IPs per 1s
    thresholdsGlobalS10: 10000       # Max total requests across all IPs per 10s
    thresholdsPerPathS10: 3000       # Max requests per normalized path per 10s
    thresholdsUniqIpsPerMinute: 2000 # Approx distinct IPs (HyperLogLog) in current minute
    # Signals (turn off to save CPU if unused)
    signalsUseDistinctIpSurge: true  # Enable HyperLogLog distinct-IP detection
    signalsCheckSuspiciousUa: true   # Add a UA-based heuristic (cheap but useful)
    # Client IP extraction — first non-empty header wins; falls back to event.ip/remoteAddr
    ipHeaders:
      - "x-forwarded-for"           # may contain CSV; first hop is taken
      - "x-real-ip"
    # Treat empty/unknown UA as suspicious; add simple signatures here
    suspiciousUserAgents:
      - "curl/"
      - "python-requests"
      - "scrapy"
      - "ahrefsbot"
extractors:
  rules:
    username:
      - source: QUERY
        key: username
      - source: BODY_JSON
        key: username
      - source: BODY_FORM
        key: username
      - source: HEADER
        key: x-user
    correlation-id:
      - source: HEADER
        key: x-correlation-id
      - source: HEADER
        key: x-request-id
      - source: HEADER
        key: correlation-id
    device:
      - source: HEADER
        key: vendor-id
      - source: HEADER
        key: x-device-id
      - source: HEADER
        key: fingerprint
    client-ip:
      - source: HEADER
        key: x-forwarded-for
      - source: HEADER
        key: x-real-ip
      - source: HEADER
        key: forwarded
    user-agent:
      - source: HEADER
        key: user-agent

threat-store:
  retention-days: 10
  max-body-bytes: 8192
  header-allowlist:
    - content-type
    - user-agent
    - x-forwarded-for
    - cf-connecting-ip
    - x-request-id

server:
  servlet:
    context-path: /api
